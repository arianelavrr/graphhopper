Par : L√©a Hemidj et Ariane Laverri√®re

L‚Äôobjectif de cette t√¢che √©tait de modifier le workflow GitHub Actions du projet GraphHopper de mani√®re √† ce que 
le processus de build √©choue automatiquement lorsque le score de mutation diminue, que les tests de mutation PIT 
soient ex√©cut√©s correctement et rapidement, qu''un Rickroll soit d√©clench√© en cas d‚Äô√©chec et que tout soit document√© 
et justifi√©. Le projet GraphHopper comprenant de nombreux modules, il √©tait n√©cessaire d‚Äôadapter le pipeline pour 
r√©duire consid√©rablement le temps d‚Äôex√©cution tout en conservant l‚Äôint√©grit√© des tests.

Nous avons configur√© Github Actions pour ex√©cuter les tests unitaires et les tests de mutation PIT, extraire le score
de mutation g√©n√©r√© par PIT, ensuite comparer ce score avec le score obtenu lors de l‚Äôex√©cution pr√©c√©dente du workflow,
puis faire √©chouer le build si le score baisse apr√®s un commit tout en d√©clenchant un Rickroll en cas d‚Äô√©chec.
On voulait aussi garder un pipeline rapide, fiable et adapt√© √† GraphHopper.

Choix d''architecture et justification:

1. On a choisi d''ex√©cuter PIT seulement sur le module core, car GraphHopper est compos√© de nombreux modules 
(core, web, tools, map-matching, navigation, etc.). Lancer PIT sur l‚Äôensemble du projet aurait √©t√© extr√™mement long 
(souvent plus de 20 minutes). Pour obtenir un pipeline performant tout en r√©pondant aux exigences du travail, nous avons 
choisi de cibler uniquement le module core, qui contient : AStar (dans routing), CustomWeighting 
(dans routing/weighting/custom) et l‚Äôessentiel de la logique algorithmique pertinente pour nos tests. Ce choix permet d''avoir
une ex√©cution PIT ultra rapide (< 1 minute), une forte coh√©rence avec les classes test√©es, et un pipeline beaucoup plus l√©ger.

2. Correction du probl√®me ${argLine} qui faisait planter PIT:

Dans GraphHopper, le pom parent int√®gre une configuration Surefire utilisant : <argLine>@{argLine}</argLine>, PIT interpr√®te
litt√©ralement cette cha√Æne, ce qui provoque une erreur : NoSuchFileException: {argLine} MINION DIED. Ce probl√®me est connu 
dans les projets qui utilisent Surefire + PIT. Pour corriger cela, nous avons ajout√© dans le pom.xml du module core :
<parseSurefireArgLine>false</parseSurefireArgLine> et forc√© une valeur vide dans le workflow : mvn -f core/pom.xml -DargLine="".
Cela emp√™che PIT de r√©utiliser la configuration Surefire et √©limine compl√®tement les erreurs MINION li√©es aux sous-processus PIT.

3. Extraction du score de mutation :

Nous avons choisi une approche universelle, extraire le premier pourcentage pr√©sent dans le rapport : grep -oP '[0-9]+(?=%)'.
Cette m√©thode est compatible avec toutes les versions PIT et tous les formats de rapport et r√©duit √† z√©ro les risques de crash 
dans l‚Äô√©tape d‚Äôextraction.

4. Comparaison entre ancien score et nouveau score
Le workflow enregistre le rapport PIT √† chaque ex√©cution avec upload-artifact, puis le t√©l√©charge au run suivant avec 
download-artifact. Une fois extrait, PREV contient le score pr√©c√©dent et CUR contient le score actuel. La comparaison est 
simple et efficace :
if [ "$PREV" != "0" ] && [ "$CUR" -lt "$PREV" ]; then
    exit 1
fi
Si le score actuel a diminu√© : le workflow √©choue.
S''il est stable ou augmente : le workflow passe.

5. Rickroll automatique en cas d‚Äô√©chec
En cas de failure, GitHub Actions affiche automatiquement :
Never gonna give you up üéµ
https://www.youtube.com/watch?v=dQw4w9WgXcQ
On aurait pu choisir un custom, mais on voulait y aller avec un classique.

Validation du workflow (tests effectu√©s):

Pour s‚Äôassurer que le workflow fonctionne dans toutes les situations, plusieurs validations ont √©t√© r√©alis√©es.
- Test 1 ‚Äî Premi√®re ex√©cution
  - Aucun rapport pr√©c√©dent disponible.
  - Le workflow doit passer.
  - Score pr√©c√©dent automatiquement sauvegard√©.
  Il fonctionne parfaitement.
- Test 2 ‚Äî Score stable
  - Aucune modification dans les tests.
  - Score inchang√©.
  Le workflow passe.
- Test 3 ‚Äî Score en baisse
  - Nous avons volontairement d√©sactiv√© un test pour provoquer une diminution.
  - R√©sultat :
    le workflow √©choue et le message "Mutation score decreased" appara√Æt, un Rickroll est affich√©.
  Exactement le comportement demand√©.
- Test 4 ‚Äî Aucun fichier PIT g√©n√©r√©
  - Rare, mais possible, donc on devait le tester.
  - Le workflow d√©tecte l‚Äôabsence d‚Äôindex.html et renvoie :
    score=0
  Sans planter.

Les mocks :

Nous avons ajout√© deux nouveaux tests unitaires utilisant la biblioth√®que Mockito afin de simuler des composants importants 
de GraphHopper. L‚Äôobjectif √©tait d‚Äôintroduire au moins deux classes de test, chacune utilisant des mocks pour simuler plusieurs
d√©pendances. Les deux tests ajout√©s sont : CustomWeightingMockTest.java et AStarMockTest.java. Ces tests int√®grent chacun 
plusieurs mocks et visent √† valider le comportement logique des composants sans n√©cessiter un graphe complet, des fichiers 
OSM ou une initialisation lourde du moteur GraphHopper.

CustomWeighting est l‚Äôun des √©l√©ments centraux du syst√®me de pond√©ration des ar√™tes. C‚Äôest un composant critique puisqu‚Äôil 
d√©termine le co√ªt utilis√© par A*, Dijkstra et tous les algorithmes de recherche de chemin. Plus sp√©cifiquement, il combine 
vitesse, priorit√©, distance, p√©nalit√©s, etc., il re√ßoit plusieurs callbacks/mappings dynamiques pour calculer ces co√ªts et il
est utilis√© dans plusieurs custom profils. Tester cette classe permet donc d''am√©liorer la robustesse du moteur de routing.

AStar est un des algorithmes principaux de recherche de chemin dans GraphHopper. Il d√©pend d‚Äôun Graph, d‚Äôune Weighting et d‚Äôun 
TraversalMode. Tester AStar permet d‚Äôassurer que les composants centraux du routage fonctionnent ou, dans ce cas, que les 
interactions avec les d√©pendances simul√©es fonctionnent correctement.

Pour CustomWeightingMockTest, CustomWeighting d√©pend de plusieurs objets complexes, voici celles qu''on a choisi de mock ainsi
que la raison: 
  - CustomWeighting.EdgeToDoubleMapping  -> √©vite d‚Äôavoir √† initialiser un graphe complet
  - CustomWeighting.MaxCalc -> simulation des r√®gles de calcul de vitesse et priorit√© maximales
  - TurnCostProvider ->	normalement utilis√© pour calculer les co√ªts de virage, mais √©tait inutile pour ce test
  - EdgeIteratorState -> une vraie ar√™te n√©cessite un graphe entier, donc on la mock
Ces 6 mocks permettent d''isoler CustomWeighting.calcEdgeWeight(...) sans d√©pendre de GraphHopper dans son int√©gralit√©.

Pour AStarMockTest, AStar d√©pend d‚Äôun graphe complet et d‚Äôune pond√©ration valide. Pour les m√™mes raisons, on mock :
  - Graph	-> impossible d‚Äôinstancier un vrai graphe l√©ger sans importer des fichiers OSM
  - Weighting -> permet d‚Äôimposer un co√ªt fixe pour v√©rifier que l‚Äôalgorithme re√ßoit les bonnes valeurs
  - EdgeIteratorState	-> utilis√© pour enrichir le test sans cr√©er de structure r√©elle
Ces mocks permettent de v√©rifier que l‚Äôalgorithme AStar manipule correctement la pond√©ration fournie.

Dans CustomWeightingMockTest, on a un Mock important :
  when(edgeToPriorityMapping.get(edge, false)).thenReturn(1.0);
Sans cette ligne, CustomWeighting d√©clenche une NullPointerException car la priorit√© est essentielle dans le calcul du poids.
Les valeurs simul√©es sont :
  - edge.getDistance() -> 100.0
  - priorit√© -> 1.0
  - autres callbacks simples
  - pas de p√©nalit√©s de direction (0.0), pour isoler le test
Nous avons choisi celles-ci, car l‚Äôobjectif n‚Äôest pas de tester la logique du profil complet mais de v√©rifier que 
CustomWeighting.calcEdgeWeight() fonctionne dans un contexte simul√© et de garantir qu‚Äôil retourne un poids valide tout en 
√©vitant les d√©pendances lourdes (graphes, chargement de donn√©es).

Dans AStarMockTest, on a un Mock essentiel :
  when(weighting.calcEdgeWeight(any(), anyBoolean())).thenReturn(5.0);
Cela assure que AStar utilisera un co√ªt constant, qu''on peut v√©rifier que le mock est correctement utilis√© et qu''on d√©couple
AStar des structures internes du graphe. Nous avons choisi ceci, car AStar.calcPath() est extr√™mement complexe et n√©cessite 
un graphe r√©el. Ce test ne cherche pas √† valider toute la logique du routing, mais seulement √† s‚Äôassurer que la pond√©ration 
est correct et bien utilis√©e et √† tester AStar dans un environnement minimal contr√¥l√©.
